<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Four Coloring (Practice) - Mr. Matt Math Club</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='20' fill='%237c3aed'/><text x='50' y='76' font-size='80' font-weight='bold' text-anchor='middle' fill='white'>M</text></svg>">
  <link rel="stylesheet" href="../styles.css">
  <style>
    /* ---- Game card ---- */
    .game-card {
      background: white;
      border-radius: 16px;
      padding: 2.5rem 2rem;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
      text-align: center;
      max-width: 520px;
      margin: 0 auto;
    }

    .card-indicator {
      font-size: 1.05rem;
      color: #7c3aed;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .instruction {
      font-size: 1.1rem;
      color: #64748b;
      margin-bottom: 1rem;
    }

    /* ---- Puzzle + Palette row ---- */
    .puzzle-row {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .puzzle-container {
      max-width: 300px;
      flex: 1 1 auto;
    }

    #puzzle-svg {
      width: 100%;
      aspect-ratio: 1;
      display: block;
      border-radius: 12px;
      background: #f8fafc;
      border: 2px solid #e2e8f0;
    }

    /* ---- Color palette ---- */
    .palette {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      flex-shrink: 0;
    }

    .swatch {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: 3px solid transparent;
      cursor: pointer;
      transition: transform 0.15s, border-color 0.15s, box-shadow 0.15s;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      padding: 0;
      outline: none;
    }

    .swatch:hover {
      transform: scale(1.1);
    }

    .swatch.selected {
      border-color: #1e293b;
      transform: scale(1.15);
      box-shadow: 0 3px 10px rgba(0,0,0,0.25);
    }

    /* ---- Status area ---- */
    .status {
      display: none;
      margin-top: 1rem;
    }

    .status.visible {
      display: block;
    }

    .success-msg {
      color: #059669;
      font-size: 1.4rem;
      font-weight: 700;
      animation: popIn 0.35s ease;
      margin-bottom: 0.5rem;
    }

    .bonus-msg {
      color: #f59e0b;
      font-size: 1.05rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
      animation: popIn 0.35s ease;
    }

    .finish-msg {
      color: #7c3aed;
      font-size: 1.2rem;
      font-weight: 600;
      margin-top: 0.5rem;
    }

    .btn {
      border: none;
      border-radius: 12px;
      padding: 0.85rem 2rem;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s, box-shadow 0.15s;
      color: white;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.15);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn-next {
      background: linear-gradient(135deg, #10b981, #34d399);
      margin-top: 0.5rem;
    }

    .btn-again {
      background: linear-gradient(135deg, #7c3aed, #4c6ef5);
      margin-top: 0.5rem;
    }

    @keyframes popIn {
      0%   { opacity: 0; transform: scale(0.8); }
      100% { opacity: 1; transform: scale(1); }
    }

    /* ---- Conflict X markers ---- */
    .conflict-x line {
      stroke: #1e293b;
      stroke-width: 6;
      stroke-linecap: round;
    }

    /* ---- Celebration burst ---- */
    .celebration {
      pointer-events: none;
      position: absolute;
      inset: 0;
      overflow: hidden;
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 2px;
      opacity: 0;
    }

    @keyframes confettiFall {
      0%   { opacity: 1; transform: translateY(0) rotate(0deg); }
      100% { opacity: 0; transform: translateY(120px) rotate(360deg); }
    }

    .game-wrapper {
      position: relative;
    }

    .puzzle-name {
      font-size: 0.95rem;
      color: #94a3b8;
      margin-bottom: 1rem;
      font-style: italic;
    }

    /* ---- Progress tracker ---- */
    .progress-tracker {
      display: flex;
      justify-content: center;
      gap: 0.6rem;
      margin-top: 1.25rem;
    }

    .progress-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2.5px solid #cbd5e1;
      background: white;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      font-size: 0;
    }

    .progress-dot.current {
      border-color: #1e293b;
      border-width: 3.5px;
      box-shadow: 0 0 0 3px rgba(30, 41, 59, 0.25);
    }

    .progress-dot.completed {
      border-color: #94a3b8;
      background: #94a3b8;
    }

    .progress-dot.clickable {
      cursor: pointer;
    }

    .progress-dot.clickable:hover {
      transform: scale(1.25);
    }

    .progress-dot.star {
      border-color: #f59e0b;
      background: #fef3c7;
    }
  </style>
</head>
<body>
  <header>
    <h1>Mr. Matt Math Club</h1>
  </header>

  <main>
    <div class="back-row">
      <a href="../index.html" class="back-btn" aria-label="Back to Activities"><svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 10H5M5 10l5-5M5 10l5 5"/></svg></a>
    </div>

    <div class="game-wrapper">
      <div class="game-card">
        <h2 class="activity-title">Four Coloring (Practice)</h2>

        <p class="instruction">Color each section &mdash; no matching neighbors!</p>

        <div class="puzzle-row">
          <div class="puzzle-container">
            <svg id="puzzle-svg" viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg"></svg>
          </div>
          <div class="palette" id="palette"></div>
        </div>

        <div class="progress-tracker" id="progress-tracker"></div>

        <div class="status" id="status"></div>
      </div>

      <div class="celebration" id="celebration"></div>
    </div>
  </main>

<script src="../js/four-color-engine.js"></script>
<script>
  // ===== Constants (from shared engine) =====
  var COLORS = FourColorEngine.COLORS;
  var REGION_DEFAULT = FourColorEngine.REGION_DEFAULT;
  var REGION_STROKE = FourColorEngine.REGION_STROKE;

  // ===== State =====
  var currentPuzzle = 0;
  var regionColors = [];
  var paletteState = { selectedColorIndex: 0, selectedEraser: false };
  var solved = false;

  // ===== DOM refs =====
  var svg = document.getElementById('puzzle-svg');
  var paletteEl = document.getElementById('palette');
  var statusEl = document.getElementById('status');
  var celebrationEl = document.getElementById('celebration');
  var progressEl = document.getElementById('progress-tracker');

  // 0 = not done, 1 = completed, 2 = completed with min colors
  var completionStatus = loadCompletionStatus();

  function loadCompletionStatus() {
    try {
      var saved = JSON.parse(localStorage.getItem('fourColoring_completion'));
      if (Array.isArray(saved) && saved.length === 15) return saved;
    } catch(e) {}
    return new Array(15).fill(0);
  }

  function saveCompletionStatus() {
    localStorage.setItem('fourColoring_completion', JSON.stringify(completionStatus));
  }


  // ===== SVG path helpers =====
  function polar(cx, cy, r, deg) {
    const rad = deg * Math.PI / 180;
    return [cx + r * Math.cos(rad), cy + r * Math.sin(rad)];
  }

  function p(x, y) {
    return Math.round(x * 10) / 10 + ',' + Math.round(y * 10) / 10;
  }

  function sectorPath(cx, cy, r, startDeg, endDeg) {
    const [x1, y1] = polar(cx, cy, r, startDeg);
    const [x2, y2] = polar(cx, cy, r, endDeg);
    const span = endDeg - startDeg;
    const largeArc = span > 180 ? 1 : 0;
    return 'M' + p(cx,cy) + ' L' + p(x1,y1) +
      ' A' + r + ',' + r + ' 0 ' + largeArc + ',1 ' + p(x2,y2) + ' Z';
  }

  function circlePath(cx, cy, r) {
    return 'M' + p(cx, cy - r) +
      ' A' + r + ',' + r + ' 0 1,1 ' + p(cx, cy + r) +
      ' A' + r + ',' + r + ' 0 1,1 ' + p(cx, cy - r) + ' Z';
  }

  function ringSectorPath(cx, cy, outerR, innerR, startDeg, endDeg) {
    const [ox1, oy1] = polar(cx, cy, outerR, startDeg);
    const [ox2, oy2] = polar(cx, cy, outerR, endDeg);
    const [ix1, iy1] = polar(cx, cy, innerR, startDeg);
    const [ix2, iy2] = polar(cx, cy, innerR, endDeg);
    const span = endDeg - startDeg;
    const largeArc = span > 180 ? 1 : 0;
    return 'M' + p(ix1,iy1) + ' L' + p(ox1,oy1) +
      ' A' + outerR + ',' + outerR + ' 0 ' + largeArc + ',1 ' + p(ox2,oy2) +
      ' L' + p(ix2,iy2) +
      ' A' + innerR + ',' + innerR + ' 0 ' + largeArc + ',0 ' + p(ix1,iy1) + ' Z';
  }

  // ===== Full-card sector helpers =====
  function rayToEdge(cx, cy, deg, w, h) {
    var rad = deg * Math.PI / 180;
    var dx = Math.cos(rad), dy = Math.sin(rad);
    var tMin = Infinity;
    if (dx > 0) { var t = (w - cx) / dx; if (t > 0 && t < tMin) tMin = t; }
    if (dx < 0) { var t = -cx / dx;      if (t > 0 && t < tMin) tMin = t; }
    if (dy > 0) { var t = (h - cy) / dy; if (t > 0 && t < tMin) tMin = t; }
    if (dy < 0) { var t = -cy / dy;      if (t > 0 && t < tMin) tMin = t; }
    return [Math.max(0, Math.min(w, cx + tMin * dx)),
            Math.max(0, Math.min(h, cy + tMin * dy))];
  }

  function perimPos(x, y, w, h) {
    var eps = 0.5;
    if (y <= eps)     return x;
    if (x >= w - eps) return w + y;
    if (y >= h - eps) return w + h + (w - x);
    return 2 * w + h + (h - y);
  }

  function clockwiseCorners(from, to, w, h) {
    var corners = [[w,0],[w,h],[0,h],[0,0]];
    var fromP = perimPos(from[0], from[1], w, h);
    var toP   = perimPos(to[0],   to[1],   w, h);
    var result = [];
    for (var i = 0; i < corners.length; i++) {
      var cp = perimPos(corners[i][0], corners[i][1], w, h);
      var between = (fromP < toP) ? (cp > fromP && cp < toP)
                                   : (cp > fromP || cp < toP);
      if (between) result.push({ pt: corners[i], pos: cp });
    }
    result.sort(function(a, b) {
      var aR = a.pos > fromP ? a.pos - fromP : a.pos + 2*(w+h) - fromP;
      var bR = b.pos > fromP ? b.pos - fromP : b.pos + 2*(w+h) - fromP;
      return aR - bR;
    });
    return result.map(function(r) { return r.pt; });
  }

  function buildFullCardSectors(cx, cy, w, h, angles) {
    var n = angles.length;
    var edgePts = angles.map(function(d) { return rayToEdge(cx, cy, d, w, h); });
    var regions = [];
    for (var i = 0; i < n; i++) {
      var ni = (i + 1) % n;
      var path = 'M' + p(cx,cy) + ' L' + p(edgePts[i][0], edgePts[i][1]);
      clockwiseCorners(edgePts[i], edgePts[ni], w, h).forEach(function(c) {
        path += ' L' + p(c[0], c[1]);
      });
      path += ' L' + p(edgePts[ni][0], edgePts[ni][1]) + ' Z';
      regions.push(path);
    }
    var adj = [];
    for (var i = 0; i < n; i++) adj.push([i, (i + 1) % n]);
    return { regions: regions, adjacency: adj };
  }

  function buildFullCardWheel(cx, cy, w, h, innerR, angles) {
    var n = angles.length;
    var edgePts  = angles.map(function(d) { return rayToEdge(cx, cy, d, w, h); });
    var innerPts = angles.map(function(d) { return polar(cx, cy, innerR, d); });
    var regions = [circlePath(cx, cy, innerR)];
    for (var i = 0; i < n; i++) {
      var ni = (i + 1) % n;
      var path = 'M' + p(innerPts[i][0], innerPts[i][1]) +
                 ' L' + p(edgePts[i][0], edgePts[i][1]);
      clockwiseCorners(edgePts[i], edgePts[ni], w, h).forEach(function(c) {
        path += ' L' + p(c[0], c[1]);
      });
      path += ' L' + p(edgePts[ni][0], edgePts[ni][1]) +
              ' L' + p(innerPts[ni][0], innerPts[ni][1]);
      var span = angles[ni] - angles[i];
      if (span < 0) span += 360;
      var la = span > 180 ? 1 : 0;
      path += ' A' + innerR + ',' + innerR + ' 0 ' + la + ',0 ' +
              p(innerPts[i][0], innerPts[i][1]) + ' Z';
      regions.push(path);
    }
    var adj = [];
    for (var i = 1; i <= n; i++) adj.push([0, i]);
    for (var i = 1; i <= n; i++) adj.push([i, i < n ? i + 1 : 1]);
    return { regions: regions, adjacency: adj };
  }

  // ===== Puzzle definitions =====
  function buildPuzzles() {
    var puzzles = [];

    // 1. Vertical Line (2 regions, need 2, give 4)
    puzzles.push({
      name: 'Vertical Line',
      numColors: 4, minColors: 2,
      regions: [
        'M0,0 L150,0 L150,300 L0,300 Z',
        'M150,0 L300,0 L300,300 L150,300 Z'
      ],
      adjacency: [[0,1]]
    });

    // 2. Gentle Arc (2 regions, need 2, give 4)
    puzzles.push({
      name: 'Gentle Arc',
      numColors: 4, minColors: 2,
      regions: [
        'M0,0 L300,0 L300,100 Q150,60 0,200 Z',
        'M0,200 Q150,60 300,100 L300,300 L0,300 Z'
      ],
      adjacency: [[0,1]]
    });

    // 3. Circle (2 regions, need 2, give 4)
    puzzles.push({
      name: 'Circle',
      numColors: 4, minColors: 2,
      regions: [
        circlePath(150, 150, 90),
        'M0,0 L300,0 L300,300 L0,300 Z ' + circlePath(150, 150, 90)
      ],
      adjacency: [[0,1]]
    });

    // 4. Three Stripes (3 regions, need 2, give 4)
    puzzles.push({
      name: 'Three Stripes',
      numColors: 4, minColors: 2,
      regions: [
        'M0,0 L300,0 L300,100 L0,100 Z',
        'M0,100 L300,100 L300,200 L0,200 Z',
        'M0,200 L300,200 L300,300 L0,300 Z'
      ],
      adjacency: [[0,1],[1,2]]
    });

    // 5. Cross (4 regions, need 2, give 4)
    puzzles.push({
      name: 'Cross',
      numColors: 4, minColors: 2,
      regions: [
        'M0,0 L150,0 L150,150 L0,150 Z',
        'M150,0 L300,0 L300,150 L150,150 Z',
        'M0,150 L150,150 L150,300 L0,300 Z',
        'M150,150 L300,150 L300,300 L150,300 Z'
      ],
      adjacency: [[0,1],[0,2],[1,3],[2,3]]
    });

    // 6. X-Diagonals (4 regions, need 2, give 4)
    puzzles.push({
      name: 'X-Diagonals',
      numColors: 4, minColors: 2,
      regions: [
        'M0,0 L300,0 L150,150 Z',
        'M300,0 L300,300 L150,150 Z',
        'M300,300 L0,300 L150,150 Z',
        'M0,300 L0,0 L150,150 Z'
      ],
      adjacency: [[0,1],[1,2],[2,3],[3,0]]
    });

    // 7. Concentric Circles (3 regions, need 2, give 4)
    var outerR = 120, innerR = 55;
    puzzles.push({
      name: 'Concentric Circles',
      numColors: 4, minColors: 2,
      regions: [
        circlePath(150, 150, innerR),
        circlePath(150, 150, outerR) + ' ' + circlePath(150, 150, innerR),
        'M0,0 L300,0 L300,300 L0,300 Z ' + circlePath(150, 150, outerR)
      ],
      adjacency: [[0,1],[1,2]]
    });

    // 8. Two-by-Three Grid (6 regions, need 2, give 4)
    puzzles.push({
      name: '2 \u00d7 3 Grid',
      numColors: 4, minColors: 2,
      regions: [
        'M0,0 L100,0 L100,150 L0,150 Z',
        'M100,0 L200,0 L200,150 L100,150 Z',
        'M200,0 L300,0 L300,150 L200,150 Z',
        'M0,150 L100,150 L100,300 L0,300 Z',
        'M100,150 L200,150 L200,300 L100,300 Z',
        'M200,150 L300,150 L300,300 L200,300 Z'
      ],
      adjacency: [[0,1],[1,2],[3,4],[4,5],[0,3],[1,4],[2,5]]
    });

    // 9. Circle + Diameter (3 regions, need 3, give 4)
    var cr = 100;
    puzzles.push({
      name: 'Circle with Diameter',
      numColors: 4, minColors: 3,
      regions: [
        'M150,50 A100,100 0 0,0 150,250 Z',
        'M150,50 A100,100 0 0,1 150,250 Z',
        'M0,0 L300,0 L300,300 L0,300 Z ' + circlePath(150, 150, cr)
      ],
      adjacency: [[0,1],[0,2],[1,2]]
    });

    // 10. Line + Triangle (3 regions, need 3, give 4)
    puzzles.push({
      name: 'Line and Triangle',
      numColors: 4, minColors: 3,
      regions: [
        'M150,30 L260,170 L40,170 Z',
        'M0,0 L300,0 L300,170 L260,170 L150,30 L40,170 L0,170 Z',
        'M0,170 L300,170 L300,300 L0,300 Z'
      ],
      adjacency: [[0,1],[0,2],[1,2]]
    });

    // 11. Y-Shape / 3 Sectors — full card (3 regions, need 3, give 3)
    (function() {
      var data = buildFullCardSectors(150, 150, 300, 300, [-90, 30, 150]);
      puzzles.push({
        name: 'Y-Shape',
        numColors: 3, minColors: 3,
        regions: data.regions,
        adjacency: data.adjacency
      });
    })();

    // 12. Wheel-4: Cross + Center Circle (5 regions, need 3, give 3)
    (function() {
      var cr2 = 50;
      var regions = [];
      regions.push(circlePath(150, 150, cr2));
      regions.push('M0,0 L150,0 L150,100 A50,50 0 0,0 100,150 L0,150 Z');
      regions.push('M150,0 L300,0 L300,150 L200,150 A50,50 0 0,0 150,100 Z');
      regions.push('M300,150 L300,300 L150,300 L150,200 A50,50 0 0,0 200,150 Z');
      regions.push('M0,150 L100,150 A50,50 0 0,0 150,200 L150,300 L0,300 Z');
      puzzles.push({
        name: 'Wheel',
        numColors: 3, minColors: 3,
        regions: regions,
        adjacency: [[0,1],[0,2],[0,3],[0,4],[1,2],[2,3],[3,4],[4,1]]
      });
    })();

    // 13. Five Slices — full card (5 regions, need 3, give 3)
    (function() {
      var angles = [];
      for (var i = 0; i < 5; i++) angles.push(-90 + i * 72);
      var data = buildFullCardSectors(150, 150, 300, 300, angles);
      puzzles.push({
        name: 'Five Slices',
        numColors: 3, minColors: 3,
        regions: data.regions,
        adjacency: data.adjacency
      });
    })();

    // 14. Seven Slices — full card (7 regions, need 3, give 3)
    (function() {
      var step = 360 / 7;
      var angles = [];
      for (var i = 0; i < 7; i++) angles.push(-90 + i * step);
      var data = buildFullCardSectors(150, 150, 300, 300, angles);
      puzzles.push({
        name: 'Seven Slices',
        numColors: 3, minColors: 3,
        regions: data.regions,
        adjacency: data.adjacency
      });
    })();

    // 15. Star Wheel — full card (6 regions, need 4, give 4)
    (function() {
      var angles = [];
      for (var i = 0; i < 5; i++) angles.push(-90 + i * 72);
      var data = buildFullCardWheel(150, 150, 300, 300, 40, angles);
      puzzles.push({
        name: 'Star Wheel',
        numColors: 4, minColors: 4,
        regions: data.regions,
        adjacency: data.adjacency
      });
    })();

    return puzzles;
  }

  var PUZZLES = buildPuzzles();

  // ===== Render =====
  function loadPuzzle(index) {
    var puzzle = PUZZLES[index];
    solved = false;
    regionColors = new Array(puzzle.regions.length).fill(null);
    borderMidpointCache = {};

    svg.innerHTML = '';

    puzzle.regions.forEach(function(d, i) {
      var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', d);
      path.setAttribute('fill', REGION_DEFAULT);
      path.setAttribute('stroke', REGION_STROKE);
      path.setAttribute('stroke-width', '2');
      path.setAttribute('fill-rule', 'evenodd');
      path.setAttribute('data-index', i);
      path.style.cursor = 'pointer';
      path.style.transition = 'fill 0.15s';
      path.addEventListener('click', function() { paintRegion(i); });
      svg.appendChild(path);
    });

    renderPalette(4);

    statusEl.classList.remove('visible');
    statusEl.innerHTML = '';

    renderProgress();
  }

  function isAccessible(index) {
    if (index === 0) return true;
    return completionStatus[index - 1] > 0;
  }

  function renderProgress() {
    progressEl.innerHTML = '';
    for (var i = 0; i < PUZZLES.length; i++) {
      var dot = document.createElement('div');
      dot.className = 'progress-dot';
      if (i === currentPuzzle) dot.classList.add('current');
      if (completionStatus[i] === 2) {
        dot.classList.add('star');
        var starSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        starSvg.setAttribute('viewBox', '0 0 24 24');
        starSvg.setAttribute('width', '14');
        starSvg.setAttribute('height', '14');
        var starPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        starPath.setAttribute('d', 'M12 2l3.09 6.26L22 9.27l-5 4.87L18.18 22 12 18.27 5.82 22 7 14.14 2 9.27l6.91-1.01z');
        starPath.setAttribute('fill', '#f59e0b');
        starSvg.appendChild(starPath);
        dot.appendChild(starSvg);
      } else if (completionStatus[i] === 1) {
        dot.classList.add('completed');
      }
      if (i !== currentPuzzle && isAccessible(i)) {
        dot.classList.add('clickable');
        (function(idx) {
          dot.addEventListener('click', function() { goToPuzzle(idx); });
        })(i);
      }
      progressEl.appendChild(dot);
    }
  }

  function goToPuzzle(index) {
    currentPuzzle = index;
    loadPuzzle(index);
  }

  function renderPalette(numColors) {
    FourColorEngine.renderPalette(paletteEl, numColors, paletteState);
  }

  function selectColor(index) {
    FourColorEngine.selectColor(paletteEl, paletteState, index);
  }

  // ===== Game logic =====
  function paintRegion(index) {
    if (solved) return;

    regionColors[index] = paletteState.selectedColorIndex;

    var paths = svg.querySelectorAll('path[data-index]');
    paths[index].setAttribute('fill', COLORS[paletteState.selectedColorIndex]);

    drawConflictMarkers();

    // Check completion
    var puzzle = PUZZLES[currentPuzzle];
    if (regionColors.every(function(c) { return c !== null; })) {
      var valid = true;
      for (var e = 0; e < puzzle.adjacency.length; e++) {
        if (regionColors[puzzle.adjacency[e][0]] === regionColors[puzzle.adjacency[e][1]]) {
          valid = false;
          break;
        }
      }
      if (valid) {
        solved = true;
        showSuccess();
      }
    }
  }

  var borderMidpointCache = {};

  function drawConflictMarkers() {
    var puzzle = PUZZLES[currentPuzzle];
    FourColorEngine.drawConflictMarkers(svg, puzzle.adjacency, regionColors, borderMidpointCache);
  }

  function showSuccess() {
    showConfetti();
    var puzzle = PUZZLES[currentPuzzle];
    var usedColors = new Set(regionColors).size;
    var isMinimal = usedColors <= puzzle.minColors;

    // Record completion
    completionStatus[currentPuzzle] = isMinimal ? 2 : 1;
    saveCompletionStatus();
    renderProgress();

    var bonus = isMinimal && puzzle.numColors > puzzle.minColors
      ? '<p class="bonus-msg">Only ' + usedColors + ' color' + (usedColors !== 1 ? 's' : '') + ' used — perfect!</p>'
      : '';

    if (currentPuzzle < PUZZLES.length - 1) {
      statusEl.innerHTML =
        '<p class="success-msg">\u{1F389} Great job!</p>' +
        bonus +
        '<button class="btn btn-next" onclick="nextPuzzle()">Next Card \u2192</button>';
    } else {
      statusEl.innerHTML =
        '<p class="success-msg">\u{1F389} Amazing!</p>' +
        bonus +
        '<p class="finish-msg">You finished all the cards!</p>' +
        '<button class="btn btn-again" onclick="restartAll()">Play Again</button>';
    }
    statusEl.classList.add('visible');
  }

  function nextPuzzle() {
    currentPuzzle++;
    loadPuzzle(currentPuzzle);
  }

  function resetPuzzle() {
    loadPuzzle(currentPuzzle);
  }

  function restartAll() {
    currentPuzzle = 0;
    paletteState.selectedColorIndex = 0;
    loadPuzzle(0);
  }

  // ===== Confetti =====
  function showConfetti() {
    FourColorEngine.showConfetti(celebrationEl);
  }

  // ===== Start =====
  loadPuzzle(0);
</script>
</body>
</html>
